https://ethereum.org/cs/developers/docs/evm/
evm
evm은 블록에서 블록으로 새로운 유효한 상태를 계산하기 위한 규칙을 정의한다.
이더리움은 분산 원장 대신 분산 상태 머신이다. 
기계 상태를 보유하는 대규모 데이터 구조이다.
https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e
evm은 명령 세트(opcode)를 사용하여 특정 작업을 실행한다.
opcode는 튜링 완전성을 갖추도록 한다.
아래와 같은 opcode가 있다.
스택 조작 opcode ( POP, PUSH, DUP, SWAP )
산술/비교/비트 연산 코드 ( ADD, SUB, GT, LT, AND, OR )
환경 opcode ( CALLER, CALLVALUE, NUMBER )
메모리 조작 연산 코드 ( MLOAD, MSTORE, MSTORE8, MSIZE )
스토리지 조작 opcode ( SLOAD, SSTORE )
프로그램 카운터 관련 opcode ( JUMP, JUMPI, PC, JUMPDEST )
opcode 중지 ( STOP, RETURN, REVERT, INVALID, SELFDESTRUCT )

opcode는 효율적으로 저장되기 위해 바이트 코드로 인코딩 됩니다.
모든 opcode에는 바이트코드가 할당된다.
예를 들어, STOP은 입니다 0x00

evm의 스택은 1024개만 담을 수 있다.

모든 계약 실행은 이더리움 노드를 실행하는 모든 사람에 의해 실행된다.
때문에 공격자는 네트워크 속도를 늦추기 위해 계산 비용이 많이 드는 작업을 많이 포함하는 계약을 만들려고 한다.
이를 방지 하기 위해 모든 opcode에는 동적 가스 비용이 부과된다.

https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf
evm은 evmcode + pc + gas + stack + memory + storage로 이루어져있다.
stack에는 1024개의 elements가 들어갈 수 있다.
memory는 휘발성 메모리로 바이트 주소 선형 메모리이다. 바이트 주소 - value 형식으로 저장한다.
storage는 비휘발성 메모리로 key-value 형식으로 저장한다.

stack에서는 opcode인 push, pop, copy, swap과 같은 연산이 진행된다.
memory에서는 mstore, mstore8, mload과 같은 연산이 진행된다. 메모리의 모든 위치는 0으로 초기화돼 있다.
storage는 key-value로 mapping된 저장공간은 sstore/sload와 같은 연산이 진행된다. memory와 마찬가지로 모든 위치는 0으로 초기화돼 있다.
evmcode는 evm이 실행할 수 있는 바이트 코드이다.

진행과정은 다음과 같다.
pc(programcounter)->evm code->operations<->stack<->memory, storage
                                        ->messagecall
operations부터 gas가 필요하다.
storage, messagecall에 더많은 gas가 필요하다.
messagecall은 다른 주소에 message를 보내는 것이다. 
이것 또한 stack과 마찬가지로 1024개로 제한돼 있다.
