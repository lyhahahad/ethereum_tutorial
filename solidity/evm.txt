https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf
*이더리움 evm 기본 개념
-이더리움은 트랜잭션 기반 상태머신이다. 
-트랜잭션은 블록에 있고 블록은 데이터의 패키지이다.
-이더리움은 상태의 관점에서는 상태체인이고 블록의 관점에서는 블록체인이다.
-하드웨어의 관점에서는 트랜잭션의 스택이다.

#world state, account, account type
-world state : account : account state mapping 변수의 집합이다.
-account : world state의 구성요소이다. 
각각의 account는 address : account state maaping변수이다.
account state(주소 상태) = nonce + balance + storage hash(account storage) + code hash(evm code)
world state -> account ->address + account state
-두가지 account 유형
eoa : nonce, balance 값만 있음.
개인키->공개키->address 160bits
contract account = nonce, balance에 evm code + storage를 포함한다. 
sender address + nonce->address 160bits

#트랜잭션
-트랜잭션 : 암화화된 단일 서명
트랜잭션은 external actor(eoa owner)의 의해 제출된다.
-종류 : contract creation + message call
contract creation은 init code를 트랜잭션을 통해 evmcode와 storage를 포함하는 contract account를 생성한다.
messagecall은 input data를 트랜잭션을 통해 address를 업데이트한다.
위의 두가지 트랜잭션은 eoa의 owner인 external actor에 의해 이루어진다.
트랜잭션의 구성요소 : nonce, gasprice, gaslimit, to, value, v r s, init or data(init = contract creation, data = message call)

#message
-message : 두가지 account 간에 메시지를 전달한다.
메시지는 데이터 그리고 value(이더에 의해 특정된)이다.
트랜잭션 혹은 evmcode에 의해 발생한다.
eoa account가 다른 account에 메시지를 전달할 때는 트랜잭션
contract account가 다른 account에 메시지를 전달할 때는 evmcode에 의해 실행된다.
4가지 케이스
eoa -> eoa(트랜잭션)
ca -> eoa(evm code)
eoa -> ca(트랜잭션)
ca -> ca(evm code)

#Decentralised database : world state를 보유한 노드가 서로 p2p로 연결된 구조.
컨트랙트, 메시지 트랜잭션은 web3 api를 통해 world state에 전달된다.
이더리움 노드는 geth, parity사 존재한다.
external actors는 노드를 통해 이더리움와 통신한다.

#Atomicity and order : 각각의 트랜잭션은 아토믹하다. 즉 더이상 쪼개질 수 없다.
트랜잭션은 오버랩될 수 없다.
트랜잭션은 순차적으로 실행된다.
트랜잭션 순서는 보장되지 않는다.
ea가 트랙잭션을 생성하면 트랜잭션 풀에 들어가고 채굴자가 트랜잭션을 선택해 블록을 만든다.
빠르게 문제를 푼 채굴자가 만든 블록이 체인에 연결된다.

#evm
evm code는 evm에서 실행된다.
world states a에서 a+1로 옮길 때 
acoount state n의 code와 storage, 트랜잭션 메시지 콜의 input data가 evm에 들어가 실행된 후 a+1의 account state n의 storage를 업데이트한다.
evm은 심플 스택 기반 아키텍쳐이다.
pc, gas, stack, memory영역으로 구성돼 있고 여기에 world state a의 account n의 storage와 evm code가 추가된다.
stack은 256bits의 요소 1024개를 수용할 수 있고
memory는 byte 주소의 선형 메모리이다.
storage는 256bits의 key와 value로 구성된 메모리이다.
stack에서는 push, pop, copy, swap 등과 같은 opcode가 실행된다.
memory는 mstore/mstore8과 같은 opcode
storage는 sstore/sload와 같은 opcode가 실행되고 둘다 0으로 초기화된다.

PUSH 01
EXP
PUSH1 00
위와 같이 구성된 코드는 숫자로 구성된 BYTECODE로 바뀌고 EVM에서 실행된다.

PC-EVMCODE - OPERATIONS - stack -memory    
GAS AVAIL -                     -storage


https://ethereum.org/cs/developers/docs/evm/
evm
evm은 블록에서 블록으로 새로운 유효한 상태를 계산하기 위한 규칙을 정의한다.
이더리움은 분산 원장 대신 분산 상태 머신이다. 
기계 상태를 보유하는 대규모 데이터 구조이다.
https://medium.com/mycrypto/the-ethereum-virtual-machine-how-does-it-work-9abac2b7c9e
evm은 명령 세트(opcode)를 사용하여 특정 작업을 실행한다.
opcode는 튜링 완전성을 갖추도록 한다.
아래와 같은 opcode가 있다.
스택 조작 opcode ( POP, PUSH, DUP, SWAP )
산술/비교/비트 연산 코드 ( ADD, SUB, GT, LT, AND, OR )
환경 opcode ( CALLER, CALLVALUE, NUMBER )
메모리 조작 연산 코드 ( MLOAD, MSTORE, MSTORE8, MSIZE )
스토리지 조작 opcode ( SLOAD, SSTORE )
프로그램 카운터 관련 opcode ( JUMP, JUMPI, PC, JUMPDEST )
opcode 중지 ( STOP, RETURN, REVERT, INVALID, SELFDESTRUCT )

opcode는 효율적으로 저장되기 위해 바이트 코드로 인코딩 됩니다.
모든 opcode에는 바이트코드가 할당된다.
예를 들어, STOP은 입니다 0x00

evm의 스택은 1024개만 담을 수 있다.

모든 계약 실행은 이더리움 노드를 실행하는 모든 사람에 의해 실행된다.
때문에 공격자는 네트워크 속도를 늦추기 위해 계산 비용이 많이 드는 작업을 많이 포함하는 계약을 만들려고 한다.
이를 방지 하기 위해 모든 opcode에는 동적 가스 비용이 부과된다.

https://takenobu-hs.github.io/downloads/ethereum_evm_illustrated.pdf
evm은 evmcode + pc + gas + stack + memory + storage로 이루어져있다.
stack에는 1024개의 elements가 들어갈 수 있다.
memory는 휘발성 메모리로 바이트 주소 선형 메모리이다. 바이트 주소 - value 형식으로 저장한다.
storage는 비휘발성 메모리로 key-value 형식으로 저장한다.

stack에서는 opcode인 push, pop, copy, swap과 같은 연산이 진행된다.
memory에서는 mstore, mstore8, mload과 같은 연산이 진행된다. 메모리의 모든 위치는 0으로 초기화돼 있다.
storage는 key-value로 mapping된 저장공간은 sstore/sload와 같은 연산이 진행된다. memory와 마찬가지로 모든 위치는 0으로 초기화돼 있다.
evmcode는 evm이 실행할 수 있는 바이트 코드이다.

진행과정은 다음과 같다.
pc(programcounter)->evm code->operations<->stack<->memory, storage
                                        ->messagecall
operations부터 gas가 필요하다.
storage, messagecall에 더많은 gas가 필요하다.
messagecall은 다른 주소에 message를 보내는 것이다. 
이것 또한 stack과 마찬가지로 1024개로 제한돼 있다.